package com.decisionbrain.vulnerabilityassessment.model.vulnerabilityfinding;

import com.decisionbrain.vulnerabilityassessment.model.dependencycheck.DependencyCheckReport;
import com.decisionbrain.vulnerabilityassessment.model.exception.InvalidJsonException;
import com.decisionbrain.vulnerabilityassessment.model.exception.OverwriteExistingFileException;
import com.decisionbrain.vulnerabilityassessment.model.trivy.TrivyReport;
import com.decisionbrain.vulnerabilityassessment.processing.dependencycheck.DependencyCheckVulnerabilityFindingsFactory;
import com.decisionbrain.vulnerabilityassessment.processing.trivy.TrivyVulnerabilityFindingsFactory;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.type.CollectionType;
import com.fasterxml.jackson.databind.type.SimpleType;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Stream;

/**
 * Represents the list of vulnerability finding to be serialized in a Json object.
 */
public class VulnerabilityFindings {
    private final List<VulnerabilityFinding> vulnerabilityFinding;
    private static final ObjectMapper objectMapper;

    static {
        objectMapper = new ObjectMapper();
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        objectMapper.registerModule(new JavaTimeModule());
    }

    public VulnerabilityFindings(List<VulnerabilityFinding> vulnerabilityFinding) {
        this.vulnerabilityFinding = Collections.unmodifiableList(vulnerabilityFinding);
    }

    public List<VulnerabilityFinding> getFindings() {
        return vulnerabilityFinding;
    }

    /**
     * This method stores a vulnerability finding report in a specified file path, either by overwriting an existing file or creating a new file.
     *
     * @param path      the file path where the report will be stored.
     * @param overwriteBehavior an enum specifying whether or not to overwriteBehavior an existing file.
     * @throws IOException                    if there is an issue with writing to the file.
     * @throws OverwriteExistingFileException if an existing file is not to be overwritten.
     */
    public void store(Path path, OverwriteBehavior overwriteBehavior) throws IOException, OverwriteExistingFileException {

        File reportsFile = new File(path.toUri());
        String jsonReport = objectMapper.writeValueAsString(vulnerabilityFinding);

        if (!reportsFile.exists()) {
            try (FileWriter fileWriter = new FileWriter(reportsFile)) {
                fileWriter.write(jsonReport);
            }
        } else if (reportsFile.exists() && overwriteBehavior.equals(OverwriteBehavior.REPLACE)) {
            try (FileWriter fileWriter = new FileWriter(reportsFile, false)) {
                fileWriter.write(jsonReport);
            }
        } else if (reportsFile.exists() && overwriteBehavior.equals(OverwriteBehavior.APPEND)) {
            List<VulnerabilityFinding> oldVulnerabilityFindings = objectMapper.readValue(reportsFile, CollectionType.construct(List.class, SimpleType.construct(VulnerabilityFinding.class)));
            List<VulnerabilityFinding> newVulnerabilityFindings = mergeReports(this.vulnerabilityFinding,  oldVulnerabilityFindings);
            String reports = objectMapper.writeValueAsString(newVulnerabilityFindings);

            try (FileWriter fileWriter = new FileWriter(reportsFile)) {
                fileWriter.write(reports);
            }
        } else {
            throw new OverwriteExistingFileException("File exists and you don't want to overwriteBehavior");
        }
    }

    /**
     * This method takes in a variable number of lists of vulnerabilityFinding and merges them into a single list.
     * @param reports is one or more lists of VulnerabilityFinding.
     * @return the merged list is returned.
     */
    public static List<VulnerabilityFinding> mergeReports(List<VulnerabilityFinding>... reports) {
        List<VulnerabilityFinding> newVulnerabilityFindings = new ArrayList<>();
        Stream.of(reports).flatMap(List::stream).forEach(newVulnerabilityFindings::add);
        return newVulnerabilityFindings;
    }


    public static class Factory {

        private Factory() {
        }

        /**
         * This method takes in an input of a DependencyCheckReport object and returns an instance of VulnerabilityFindings that contains the vulnerabilities present in the dependency check report.
         *
         * @param dependencyCheckReport is the DependencyCheckReport object containing the vulnerability information in dependency check report.
         * @return an instance of VulnerabilityFindings containing the vulnerabilities in dependency check report.
         */
        public static VulnerabilityFindings fromReport(DependencyCheckReport dependencyCheckReport) {
            DependencyCheckVulnerabilityFindingsFactory dependencyCheckVulnerabilityFindingsFactory = new DependencyCheckVulnerabilityFindingsFactory(dependencyCheckReport);
            var vulnerabilityFinding = dependencyCheckVulnerabilityFindingsFactory.createReports();
            return new VulnerabilityFindings(vulnerabilityFinding);
        }

        /**
         * This method takes an input of a TrivyReport object and returns an instance of VulnerabilityFindings that contains the vulnerabilities present in the trivy report.
         *
         * @param trivyReport is the TrivyReport object containing the vulnerability information in trivy report.
         * @return an instance of VulnerabilityFindings containing the vulnerabilities in trivy report.
         */
        public static VulnerabilityFindings fromReport(TrivyReport trivyReport) {
            TrivyVulnerabilityFindingsFactory trivyVulnerabilityFindingsFactory = new TrivyVulnerabilityFindingsFactory(trivyReport);
            var vulnerabilityFinding = trivyVulnerabilityFindingsFactory.createReports();
            return new VulnerabilityFindings(vulnerabilityFinding);
        }

        /**
         *  This method parses a vulnerability findings report from a file that contains an array of vulnerability findings.
         * @param vulnerabilityFindingsReport is the file that contains the vulnerability findings.
         */
        public static VulnerabilityFindings fromFile(File vulnerabilityFindingsReport) throws IOException, InvalidJsonException {
            Objects.requireNonNull(vulnerabilityFindingsReport, "Function parameter vulnerabilityFindingsReport does not support null.");

            if(!vulnerabilityFindingsReport.exists()) {
                throw new FileNotFoundException("File not found");
            }

            if(!isValidJson(vulnerabilityFindingsReport)) {
                throw new InvalidJsonException("Pass a valid json");
            }

            List<VulnerabilityFinding> vulnerabilityFindings = objectMapper.readValue(vulnerabilityFindingsReport, CollectionType.construct(List.class, SimpleType.construct(VulnerabilityFinding.class)));
            return new VulnerabilityFindings(vulnerabilityFindings);
        }

        private static boolean isValidJson(File jsonFile) {
            try {
                objectMapper.readTree(jsonFile);
                return true;
            }catch (Exception e){
                return false;
            }
        }

    }
}
